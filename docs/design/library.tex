\chapter{The Haero Library}
\labelchapter{library}

In this chapter, we describe the Haero software library itself, and its usage
within an atmospheric model.

\section{Overview}
\labelsection{lib:overview}

Haero is designed to provide a modal aerosol capability to an atmospheric model
written in C++ and/or Fortran. It makes no attempt to describe or evolve any
atmospheric phenomena outside of aerosols. Instead, Haero evolves the state of
aerosols within a modal aerosol model as part of a broader atmospheric
{\bf host model}---a mathematically consistent description of the atmosphere.

To use Haero in your own host model, you write code to interact to construct
a modal aerosol system and invoke aerosol processes on that system. Haero gives
you all the flexibility and control you need to define how the aerosol processes
couple with and interoperate with the other processes in the host model. In this
sense, Haero is a set of building blocks you can use to construct the most
appropriate modal aerosol representation for your host model.

Haero provides an interface for running aerosol processes to evolve a set of
state data within a single atmospheric column. You can evolve several columns
in parallel, as long as state data is provided for each column.

All quantities in Haero are specified using the International System of Units
(SI) unless otherwise specified. In both code comments and documentation, we
place square brackets indicating units after the description of a quantity
(e.g. simulation time [s]).

\subsection{Aerosol Systems}
\labelsubsection{lib:systems}

Haero's representation of aerosols relies on a set of elementary data structures
that define the assumptions underlying a specific modal aerosol system. These
elements are:

\begin{itemize}
  \item An {\bf Aerosol Model}: the definition of a specific modal aerosol
        system to be simulated
  \item {\bf Modes}: statistical representations of aerosol particle populations
        organized by particle size
  \item {\bf Species}: aerosol and gas molecules of interest. Each aerosol
        species belongs to a single aerosol mode and is tracked by mass and
        number.
\end{itemize}

These entities define the aerosol system of interest in Haero, and provide
any related {\bf metadata} needed to make decisions about how an aerosol
processes does its work.

\subsection{Aerosol State Data}
\labelsubsection{lib:state}

Haero deals with two distinct types of state variables:

\begin{itemize}
  \item {\bf Prognostic variables}: variables that are evolved in time according
        to a system of differential equations
  \item {\bf Diagnostic variables}: variables that are algebraically related to
        other variables, whether those variables are prognostic or diagnostic
\end{itemize}

Prognostic variables are quantities that possess an initial state and are
evolved forward in time by their {\bf tendencies} (time derivatives). It is
not possible to construct the value of a prognostic variable at time $t$ without
an initial condition at some time $t_0$ and a tendency defined over the period
$\left[t_0, t\right]$.

The concept of a ``diagnostic'' variable is more general than its name suggests.
The word "diagnostic" suggests that the variable is used only as an indicator
by a human attempting to ``diagnose'' some atmospheric condition. In fact, a
diagnostic variable can be any variable whose state can be constructed at any
instant in time, using only the relevant prognostic variables. In this sense,
a diagnostic variable serves as a ``shared'' variable that can be computed at
the appropriate time, and used by one or more prognostic processes.

Haero's aerosol state data lives in multi-dimensional arrays within ``smart
containers'':

\begin{itemize}
  \item The \verb Prognostics  container contains prognostic state variables
        specific to aerosols
  \item The \verb Atmosphere  container contains a thermodynamic description
        of the atmosphere in which an aerosol system is embedded
  \item The \verb Diagnostics  container contains a registry of diagnostic
        variables shared amongst various aerosol processes, and made available
        for output
\end{itemize}

The arrays in these data structures are stored in \verb View  objects provided
by the Kokkos C++ library. Aerosol state data is allocated in C++, but available
for use in Fortran for implementing aerosol processes or for using Haero
from within a Fortran host model. Atmospheric state data is provided by the
host model.

\subsection{Aerosol Processes}
\labelsubsection{lib:processes}

The aerosol ``life cycle'' consists of a set of complicated physical processes
involving many participants, with a wide range of length and time scales. These
different scales demand a degree of flexibility in how we evaluate changes to
the state of an aerosol system. For example, we expect to be able to resolve
processes whose time scale is similar to or larger than the time scale for
convection in the atmosphere, whereas processes with faster time scales must be
treated in some special way that accommodates a relaxation or equilibration
process.

Haero provides data structures for constructing two distinct types of aerosol
processes:

\begin{itemize}
  \item A {\bf prognostic process} accepts a set of prognostic and diagnostic
        variables as input, and computes as output one or more tendencies for a
        corresponding set of prognostic variables. It does not make any changes
        to any of its inputs.
  \item A {\bf diagnostic process} accepts a set of prognostic variables as
        input, and updates one or more diagnostic variables in place so that
        these variables are consistent with the prognostic variables.
\end{itemize}

A process consists of a set of parameterizations that encode simplifying
assumptions about a specific stage of the aerosol life cycle into an algorithm
that computes the relevant quantities of interest. The processes provided by
Haero, and their various parameterizations, are described in \refchapter{processes}.

These processes are the true assets of the Haero library. They can be
implemented in C++, in Fortran, or in both. This allows aerosol researchers to
make their latest parameterizations available in the Haero library, while
providing software engineers with a ``future-proof'' environment for optimizing
these and other parameterizations for DOE's Leadership Class Facilities.

That's an orbit-level view of the Haero library. Now let's take a closer look at
each of these aspects.

\section{Aerosol Systems in Haero}
\labelsection{lib:systems}

To model a specific aerosol system in Haero, we must answer some questions:

\begin{itemize}
  \item What modes are required to accurately characterize the distribution of
        interesting particle sizes?
  \item What species are present in the system, and in what modes are they
        allowed to appear?
  \item How many vertical levels are needed to resolve the profile of aerosols
        in the system?
  \item Which physical processes are relevant to a simulation of interest?
        Should any processes be excluded, to answer a specific question about
        how the processes interact with each other, or because they are not
        signficant for the system?
\end{itemize}

Each of these decisions greatly affects the nature of the model---systems with
different answers to these questions will have very different behavior. When we
define a Haero simulation, we encode the answers to these decisions in an
{\bf aerosol model} variable.

What do we mean by an ``aerosol model'', exactly? One can think about it in a
few different ways.

\begin{itemize}
  \item An aerosol model specifies the physics (or the approximations to the
        physics, if you like) represented by an aerosol simulation.
  \item An aerosol model stores a set of ``global variables'' that govern the
        behavior for the simulation of a single aerosol system.
  \item Every aerosol system is described by exactly one aerosol model.
  \item The aerosol model encodes the assumptions made about an aerosol system's
        representation. It does not define the state of that system at any given
        time. In this sense, all of its information is ``timeless''.
\end{itemize}

\subsection{The Model Type}
\labelsubsection{lib:model}

In Haero, an aerosol model is defined by the \verb Model  type, defined within
the \verb haero  namespace. Interfaces to this type are provided in both C++ and
Fortran.

Below is an abbreviated look at the \verb Model  C++ class. The source code for
this class can be found in the \verb haero/model.hpp  and
\verb haero/model.cpp files within the repository. Reading through this class,
you'll see references to various other data structures. We describe these data
structures in subsequent sections.

\lstset{language=[11]{c++}}
\begin{lstlisting}
class Model final {
  public:

  // Constructor -- creates a new model given all relevant data.
  Model(const SelectedProcesses& selected_processes,
        const std::vector<Mode>& aerosol_modes,
        const std::vector<Species>& aerosol_species,
        const std::map<std::string, std::vector<std::string> >& mode_species,
        const std::vector<Species>& gas_species,
        int num_levels);

  // Creates a new Prognostics object that can be used with this Model, given
  // a set of views representing aerosol data managed by a host model.
  Prognostics* create_prognostics(Kokkos::View<PackType**>& int_aerosols,
                                  Kokkos::View<PackType**>& cld_aerosols,
                                  Kokkos::View<PackType**>& gases,
                                  Kokkos::View<PackType**>& modal_num_concs) const;

  // Creates a set of diagnostic variables for use with this model.
  Diagnostics* create_diagnostics() const;

  // Runs the (prognostic) aerosol process of the given type, computing any
  // relevant tendencies.
  void run_process(ProcessType type,
                   Real t, Real dt,
                   const Prognostics& prognostics,
                   const Atmosphere& atmosphere,
                   const Diagnostics& diagnostics,
                   Tendencies& tendencies);

  // Runs the (diagnostic) aerosol process of the given type, updating all
  // relevant diagnostic variables in place.
  void update_diagnostics(ProcessType type, Real t,
                          const Prognostics& prognostics,
                          const Atmosphere& atmosphere,
                          Diagnostics& diagnostics);

  // Returns the selected set of processes associated with this aerosol model.
  const SelectedProcesses& selected_processes() const;

  // Returns the list of modes for the context.
  const std::vector<Mode>& modes() const;

  // Returns the list of aerosol species for the context.
  const std::vector<Species>& aerosol_species() const;

  // Returns the list of aerosol species associated with the model with the
  // given mode index.
  std::vector<Species> aerosol_species_for_mode(int mode_index) const;

  // Returns the total number of distinct aerosol species populations in the
  // model, counting appearances of one species in different modes separately.
  int num_aerosol_populations() const { return num_aero_populations_; }

  // Returns the list of gas species for the context.
  const std::vector<Species>& gas_species() const;

  // Returns the number of vertical levels (cells) in each atmospheric column.
  int num_levels() const;
};
\end{lstlisting}

In C++, you can create as many \verb Model  variables as you like, though
there's usually no reason to do so, unless you're running an ensemble of
simulations whose underlying assumptions differ beyond their initial states.

Haero's Fortran interface provides a \verb model_t  derived type with a subset
of the information available to the C++ \verb Model  type. While the Fortran
interface doesn't have ``feature parity'' with its C++ counterpart, we argue
that it provides ample information for implementing aerosol processes in
Fortran.

\lstset{language=[03]{fortran}}
\begin{lstlisting}
type :: model_t
  ! The aerosol modes in the model, in indexed order.
  type(mode_t), dimension(:), allocatable :: modes
  ! The number of modes in the model. Equal to size(modes).
  integer :: num_modes
  ! The number of actual species that exist within each mode.
  integer, dimension(:), allocatable :: num_mode_species
  ! population index offsets for modes.
  integer, dimension(:), allocatable :: population_offsets
  ! The total number of distinct aerosol populations.
  integer :: num_populations
  ! The aerosol species within each mode. Indexed as (mode, species).
  type(species_t), dimension(:,:), allocatable :: aero_species
  ! The gas species in the model.
  type(species_t), dimension(:), allocatable :: gas_species
  ! The number of vertical levels in each column.
  integer :: num_levels
contains
  ! Given a population index, compute mode and species indices
  procedure :: get_mode_and_species => m_get_mode_and_species
end type
\end{lstlisting}

In Fortran, a single global \verb model_t  variable, \verb model , is provided
within the \verb haero  module. This variable is automatically populated with
data by Haero before any work is done, so there's no need to create it or
modify it yourself. {\em Do not attempt to change any data within
this global variable}.

Because the model definition is provided as a global variable, only one instance
of an aerosol model is available to Fortran implementations of aerosol processes.

\subsection{The Mode Type}
\labelsubsection{lib:modes}

We've seen how the dynamics of aerosols can be represented mathematically
by evolution equations for moments of modal distribution functions. Modes
simplify the description of aerosol particles in terms of their size: instead of
representing a population of particles with a distribution function
$n(V_p, \vec{x}, t)$ that varies continuously with the size of the particle, we
introduced $M$ discrete modes and declared that these modes partition the
population of aerosol particles in the sense of the modal assumption as given
by \refeq{modal_n}.

The essential information in a mode is the range of particle sizes it
encompasses, $[D_{\min}, D_{\max}]$, and its geometric standard deviation,
$\sigma_g$. In Haero's C and C++ interfaces,
we represent an aerosol mode with the \verb|Mode| struct:

\lstset{language=[11]{c++}}
\begin{lstlisting}
struct Mode {
  std::string name;  // a unique identifier for the mode
  Real min_diameter; // the mode's minimum particle diameter [m]
  Real max_diameter; // the mode's maximum particle diameter [m]
  Real mean_std_dev; // the geometric mean standard deviation for the mode [m]
};
\end{lstlisting}

Haero's Fortran interface offers a \verb mode_t  data structure, equivalent to
the C++ \verb Mode  class. This data structure is defined in the \verb haero  Fortran
module:

\lstset{language=[03]{fortran}}
\begin{lstlisting}
type :: mode_t
  ! Mode name
  character(len=:), allocatable :: name
  ! Minimum particle diameter [m]
  real(wp) :: min_diameter
  ! Maximum particle diameter [m]
  real(wp) :: max_diameter
  ! Geometric mean standard deviation [m]
  real(wp) :: mean_std_dev
end type
\end{lstlisting}

In principle, a Haero calculation can support any number of modes, but care
must be taken to ensure that the modal assumptions remain valid, and that
the parametrizations selected can accommodate the given modes.

\subsection{The Species Type}
\labelsubsection{lib:species}

Each aerosol mode consists of one or more particle species. Additionally,
gas particles also come in different species. Both aerosol particles and
gas particles have physical properties that are described by the
\verb Species  data type.

A particle species is a specifically-identified molecular assembly with
a number of relevant physical properties. The fundamental description of a
species includes

\begin{itemize}
  \item a descriptive name (e.g. \verb "sulfate" )
  \item a symbolic name (e.g. \verb SO4 , for sulfate)
  \item information about the chemical properties of the species
\end{itemize}

In C++, we represent this information in the following way:

\lstset{language=[11]{c++}}
\begin{lstlisting}
struct Species {
  std::string name;          // full species name
  std::string symbol;        // abbreviated symbolic name
  Real molecular weight;     // molecular weight [g/mol]
  Real crystalization_point; // crystalization point [?]
  Real deliquescence_point;  // deliquenscence point [?]
};
\end{lstlisting}

In Fortran, a species is defined by the following derived type:
\lstset{language=[03]{fortran}}
\begin{lstlisting}
type :: species_t
  ! Species name
  character(len=:), allocatable :: name
  ! Species symbol (abbreviation)
  character(len=:), allocatable :: symbol
  ! Molecular weight [g/mol]
  real(wp) :: molecular_wt
  ! Crystalization point [?]
  real(wp) :: crystal_pt
  ! Deliquenscence point [?]
  real(wp) :: deliques_pt
end type
\end{lstlisting}

\section{State Variables in Haero}
\labelsection{lib:state}

Once a model variable has been created that defines an aerosol system, you can
create state variables for that system. The state of an aerosol system is
defined by the following prognostic variables within the \verb Prognostics  data
structure:

\begin{itemize}
  \item {\bf aerosol modal mass mix fraction} $q_{m,s}$ [kg aerosol species $s$ /kg dry air]:
        the ratio of aerosol mass to dry air mass for aerosol species $s$
        occupying mode $m$
  \item {\bf gas mass mix fraction} $q_g$ [kg gas species $g$/kg dry air]: the
        ratio of the mass of gas species $g$ to dry air mass
  \item {\bf modal number concentrations} $n_m$ [\# /kg dry air]: the total number of
        particles per unit mass of dry air in the mode $m$
\end{itemize}

The state of the atmosphere (expressed in averaged thermodynamic quantities
like pressure and temperature) greatly affects the behavior of aerosols, so
this atmosphere state information is made available in the \verb Atmosphere  data
structure.

Finally, the model possesses a set of diagnostic variables, stored in the
\verb Diagnostics  data structure, that depend on its selected aerosol processes
(which are discussed in a later section).

How does one create a set of state variables given a model variable? Recall that
the \verb Model  C++ class provides the following two functions, which you can
call directly yourself, given a pointer to a C++ variable called \verb model :

\begin{itemize}
  \item \verb model->create_prognostics(...)  : returns a pointer to a new C++
    \verb Prognostics  container, given views that store aerosol prognostics
  \item \verb model->create_diagnostics()  : returns a pointer to a new C++
    \verb Diagnostics  container
\end{itemize}

These functions don't take any parameters---they just use the information within
the model variable. A host model is responsible for creating its own
\verb Atmosphere  objects, because it manages the memory within the underlying
views.

By the way, you don't always have to call these functions yourself. State
variables are automatically created if you're using the Haero driver or
implementing a parameterization in C++ or Fortran. However, if you're using
Haero within your own host model, or if you're writing a unit test for your
parameterization, you must call these functions to obtain containers for your
aerosol model's state data.

The \verb Prognostics , \verb Atmosphere , and \verb Diagnostics  containers
store state data in multidimensional arrays allocated in C++ but made available
to both C++ and Fortran. The data for each array is stored within a Kokkos
\verb View .

\subsection*{Kokkos Views}
\labelsubsection{lib:views}

The C++ programming language has lots of features, but remarkably it includes no
mechanism for allocating multidimensional arrays at runtime. The Kokkos C++
library fills this gap by providing a data structure called a \verb View . A
\verb View  is essentially an interface that allows a C++ programmer to treat a
chunk of memory like a multidimensional array.

A \verb View  has a rank and a set of dimensions, just like an allocatable
Fortran array. You access a \verb View  in the same way that you'd access a
Fortran array, except that C++ uses row-major indexing instead of Fortran's
column-major indexing. So for a rank-3 view \verb f  that you access in C++
as \verb f(i,j,k) , you would access the corresponding array in Fortran as
\verb f(k,j,i) .

\subsubsection*{Digression: Packs and Vectorization}
\labelsubsubsection{lib:packs}

Haero uses Views that consist of \verb Pack  objects instead of floating
point numbers. A \verb Pack  (or just ``pack'') is a contiguous array of numbers
that allows a modern CPU or GPU to vectorize calculations using special
instructions.

When executing a vector instruction, a processor performs arithmetic on more
than one number at a time within a mathematical expression. In many cases,
vectorizing expressions can produce significantly faster code. The cost of this
optimization is that a pack represents several numbers, not one. This can make
it tricky to reason about the physical quantities stored in a pack.

Haero uses packs with a size (number of contiguously stored numbers) set at
compile time by the CMake variable \verb HAERO_PACK_SIZE . To simplify the
process of reasoning about packs, Haero uses these objects one way only:
in Haero a pack stores data for \verb HAERO_PACK_SIZE  vertical levels in
a column. Thus, a pack contains data for exactly one variable (with the same
units and physical interpretation) whose values span one or more vertical
levels.

This is the easiest way for Haero to support vectorization. It does mean,
however, that the number of vertical levels in a column differs in general from
the number of packs spanning a vertical level. For example, a column of data
with 72 vertical levels running in a Haero build with a \verb HAERO_PACK_SIZE  of
2 contains $36 = 72 / 2 $ packs in its vertical extent.

\subsubsection*{Haero Views}

Because Haero is concerned with arrays having very specific dimensions, we
define some named types that correspond to views/arrays that span specific
spaces:

\begin{table}[htbp]
\centering
\caption{Named C++ View Types}
\label{tab:viewtypes}
\begin{tabular}{|l|l|p{6cm}|l|l|}
  \toprule
  View Name & Rank & Description & C++ & Fortran \\
  \midrule
  \verb ColumnView  & 1 & Maps a vertical level index $k$ to a pack & \verb v(k)  & \verb v(k) \\
  \verb SpeciesColumnView  & 2 & Maps a population index $p$ and a vertical level index $k$ to a pack & \verb v(p,k)  & \verb v(k,p) \\
  \verb ModalColumnView & 2 & Maps a mode index $m$ and a vertical level index $k$ to a pack & \verb v(m,k)  & \verb v(k,m) \\
  \bottomrule
\end{tabular}
\end{table}

The \verb Prognostics , \verb Atmosphere , and \verb Diagnostics  containers
described below make use of these named types.

\subsection{Prognostics Type}
\labelsubsection{lib:prognostics}

The \verb Prognostics  C++ class provides access to the prognostic variables
that define aerosols in a modal description. Here's the C++ class interface
(abbreviated for brevity---see the full interface in \verb haero/prognostics.hpp ):

\lstset{language=[11]{c++}}
\begin{lstlisting}
class Prognostics final {
  public:
  // Returns the number of aerosol modes in the system.
  int num_aerosol_modes() const;

  // Returns the number of aerosol species in the mode with the given index.
  int num_aerosol_species(int mode_index) const;

  // Returns the number of gas species in the system.
  int num_gas_species() const;

  // Returns the number of vertical levels in the system.
  int num_levels() const;

  // Returns the view storing interstitial aerosol species mass mixing fraction
  // data.
  const SpeciesColumnView& interstitial_aerosols() const;

  // Returns the view storing cloud-borne aerosol species mass mixing fraction
  // data.
  const SpeciesColumnView& cloudborne_aerosols() const;

  // Returns the view storing mass mixing fraction data for gas species.
  const SpeciesColumnView& gases() const;

  // Returns the view storing modal number concentrations.
  const ModalColumnView& modal_num_concs() const;

  // Scales the given set of tendencies and adds it into this state, summing
  // the values of the prognostic variables in place.
  void scale_and_add(Real scale_factor, const Tendencies& tendencies);
};
\end{lstlisting}

Typically, you never modify a \verb Prognostics  variable directly. Instead, you
compute a set of tendencies (in a \verb Tendencies  variable, which is very
similar to a \verb Prognostics  variable) and accumulate them into your
\verb Prognostics  variable by calling \verb scale_and_add .

The Fortran version of the \verb Prognostics  type is similar, and offers
access to Fortran multidimensional arrays instead of C++ views. For cleaner
syntax, this type uses bound procedures to return pointers to its arrays.

\lstset{language=[03]{fortran}}
\begin{lstlisting}
  type :: prognostics_t
  contains
    ! Access to interstitial aerosol mix fractions array (no dummy arguments)
    procedure :: interstitial_aerosols => p_int_aero_mix_frac
    ! Access to cloudborne aerosol mix fractions array (no dummy arguments)
    procedure :: cloudborne_aerosols => p_cld_aero_mix_frac
    ! Access to gas mix fractions array (no dummy arguments)
    procedure :: gases => p_gas_mix_frac
    ! Access to modal number concentrations array (no dummy arguments)
    procedure :: modes => p_modal_num_concs
  end type
\end{lstlisting}

\subsection{Atmosphere Type}
\labelsubsection{lib:atmosphere}

The \verb Atmosphere  C++ class stores a fixed set of state variables that
describe the atmosphere, such as

\begin{itemize}
  \item temperature [K]
  \item pressure [Pa]
  \item relative humidity [-]
  \item heights at level interfaces [m]
\end{itemize}

Each of these variables are stored in \verb ColumnView  objects whose memory
is managed by the host model.

{\em This data structure is new, so we'll be adding and changing these state
variables a bit in the near future.}

\subsection{Diagnostics Type}
\labelsubsection{lib:diagnostics}

The \verb Diagnostics  C++ class stores a dynamically-determined set of
diagnostic variables that correspond to the specific parameterizations available
to the aerosol model that created it. The variables are identified by unique
tokens that can be retrieved by name.

\lstset{language=[11]c++}
\begin{lstlisting}
class Diagnostics final {
  public:
  // Returns the number of aerosol modes in the system.
  int num_aerosol_modes() const;

  // Returns the number of aerosol species in the mode with the given index.
  int num_aerosol_species(int mode_index) const;

  // Returns the number of gas species in the system.
  int num_gas_species() const;

  // Returns the number of vertical levels in the system.
  int num_levels() const;

  // Returns a unique token that identifies the given (non-modal) variable
  // within this object. Returns VAR_NOT_FOUND if this variable does not exist.
  Token find_var(const std::string& name) const;

  // Returns the view storing the diagnostic variable with a name corresponding
  // to the given token. If such a variable does not exist, this throws an
  // exception.
  ColumnView& var(const Token token);

  // Returns a unique token that identifies the given modal aerosol variable
  // within this object. Returns VAR_NOT_FOUND if this variable does not exist.
  Token find_aerosol_var(const std::string& name) const;

  // Returns the view storing the modal aerosol diagnostic variable with a name
  // corresponding to the given token. If such a variable does not exist, this
  // throws an exception.
  SpeciesColumnView& aerosol_var(const Token token);

  // Returns a unique token that identifies the given gas variable within this
  // object. Returns VAR_NOT_FOUND if this variable does not exist.
  Token find_gas_var(const std::string& name) const;

  // Returns the view storing the gas diagnostic variable with a name
  // corresponding to the given token. If such a variable does not exist, this
  // throws an exception.
  SpeciesColumnView& gas_var(const Token token);

  // Returns a unique token that identifies the given modal variable within
  // this object. Returns VAR_NOT_FOUND if this variable does not exist.
  Token find_modal_var(const std::string& name) const;

  // Returns the view storing the mode-specific diagnostic variable with a name
  // corresponding to the given token. If such a variable does not exist, this
  // throws an exception.
  ModalColumnView& modal_var(const Token token);
};
\end{lstlisting}

The Fortran version of \verb Diagnostics , like its \verb Prognostics  counterpart,
uses bound procedures to provide access to its array data. Each one of these
bound procedures accepts a single dummy argument: the name of the desired
diagnostic variable.

\lstset{language=[03]{fortran}}
\begin{lstlisting}
  type :: diagnostics_t
  contains
    ! Returns true if the column variable with the given name exists.
    procedure :: has_var => d_has_var
    ! Returns the column variable with the given name.
    procedure :: var => d_var
    ! Returns true if an aerosol diagnostic variable with the given name exists.
    procedure :: has_aerosol_var => d_has_aerosol_var
    ! Returns the aerosol diagnostic variable with the given name.
    procedure :: aerosol_var => d_aerosol_var
    ! Returns true if a gas diagnostic variable with the given name exists.
    procedure :: has_gas_var => d_has_gas_var
    ! Returns the gas diagnostic variable with the given name.
    procedure :: gas_var => d_gas_var
    ! Returns true if a modal diagnostic variable with the given name exists.
    procedure :: has_modal_var => d_has_modal_var
    ! Returns the modal diagnostic variable with the given name.
    procedure :: modal_var => d_modal_var
  end type
\end{lstlisting}

At this point, you might wonder how a \verb Diagnostics  variable knows which
variables it needs. In fact, the \verb Diagnostics  class provides functions for
creating variables that it needs. The C++ \verb Model  variable used to create
a \verb Diagnostics  variable knows this information, and automatically calls
these functions for you.

For examples of how the \verb Prognostics , \verb Atmosphere , and
\verb Diagnostics  types are used in practice, take a look at one of the
existing aerosol process implementations.

\section{Aerosol Processes in Haero}
\labelsection{lib:processes}

The aerosol life cycle consists of several important and distinct physical
processes. As we mentioned in \refsubsection{lib:processes}, there are
{\bf prognostic processes}, which compute tendencies for prognostic variables,
and there are {\bf diagnostic processes}, which update diagnostic variables
in place.

Haero offers data structures that make it very easy to implement these two types
of processes. Because the structure of a given process doesn't depend on the
details of its implementation, we can define abstract interfaces for these
processes. These abstract interfaces simplify the development of a process---
instead of designing a new process from the ground up every time you want to
add new functionality to Haero, you can simply implement a small number of
functions (or subroutines) that define the behavior of a process, and let the
Haero library handle the details of how these processes are created and used.

For detailed descriptions of the specific processes provided by Haero, take a
look at \refchapter{processes}. You can find examples of source code for
Haero's processes in the \verb haero/processes  subdirectory.

\subsection{The Prognostic Process Interface}
\labelsubsection{lib:prognostic_process}

A prognostic process has three behaviors which must be defined by any
implementation. Each of these behaviors is implemented in a C++ function or
a Fortran subroutine.

\begin{enumerate}
  \item {\bf initialization}: the process must be able to allocate any resources
        it needs to do its work. These resources include temporary work arrays,
        look-up tables, and quantities that need to be precomputed. State data
        is not managed by processes, so it's not included in process
        initialization. If nothing needs to be done for initialization, its
        function or subroutine body can be empty.
  \item {\bf running}: the process must know how to ``run''. In other words, it
        must define a procedure for computing tendencies for a relevant set of
        prognostic variables given their current values, and the current values
        of any diagnostic variables. The function or subroutine that implements
        this behavior does not apply these tendencies to any prognostic
        variables---it simply computes the tendencies and returns.
  \item {\bf finalization}: at the end of a simulation program, when the aerosol
        system is destroyed, the process must free all resources it allocated
        in its initialization. If no resources are allocated, the function or
        subroutine body implementing finalization can be empty.
\end{enumerate}

Haero provides an object-oriented approach for implementing a process in terms
of this simple interface. In an object-oriented approach, an abstract interface
is encoded in a ``base class''---a data type that declares the necessary
functions and subroutines. Then any implementation of this interface is defined
in a data type ``derived'' from that base class.

Haero uses the object-oriented features of C++ for process development. All
prognostic process implementations are derived from a C++ base class called
\verb PrognosticProcess . This is true regardless of whether you implement the
process using C++ or Fortran.

The \verb PrognosticProcess  provides the following interface (see
\verb haero/process.hpp  for more details):

\lstset{language=[11]{c++}}
\begin{lstlisting}
class PrognosticProcess {
  public:

  // Constructor, called by all PrognosticProcess subclasses.
  PrognosticProcess(ProcessType type, const std::string& name):
    type_(type), name_(name) {}

  // Destructor.
  virtual ~PrognosticProcess() {}

  // Override this method if your aerosol process needs to be initialized
  // with information about the model. The default implementation does nothing.
  virtual void init(const Model& model) {}

  // Override this method to implement the aerosol process using the specific
  // parameterization for the subclass.
  virtual void run(const Model& model,
                   Real t, Real dt,
                   const Prognostics& prognostics,
                   const Atmosphere& atmosphere,
                   const Diagnostics& diagnostics,
                   Tendencies& tendencies) const = 0;
};
\end{lstlisting}

In addition to the ``constructor'' function used to create an instance of a
\verb PrognosticProcess  variables, this interface declares three functions
(\verb init , \verb run , and the destructor function \verb \~PrognosticProcess )
that correspond to the three behaviors described above.

The constructor accepts a process type that indicates what stage of the aerosol
life cycle it represents. A \verb ProcessType  data structure is an
``enumerated type'' that enumerates the various stages:

\begin{lstlisting}
// This enumerated type lists all relevant physical aerosol processes.
enum ProcessType {
  ActivationProcess,
  CloudBorneWetRemovalProcess,
  CoagulationProcess,
  CondensationProcess,
  DryDepositionProcess,
  EmissionsProcess,
  InterstitialWetRemovalProcess,
  NucleationProcess,
  ResuspensionProcess,
  WaterUptakeProcess
};
\end{lstlisting}

Let's explore how we might implement a prognostic aerosol process in C++ and in
Fortran. Here we describe only the steps needed to implement the process itself.
You must also testing your process to make sure it behaves the way you think it
does! The procedure for testing an aerosol process is described in
\refchapter{testing}.

\subsubsection{C++ prognostic processes}
\labelsubsubsection{lib:prognostic_cxx}

In C++, all you have to do in order to implement a prognostic process is to
define a class with a specific name, derived from the
\verb PrognosticProcess  base class. For example, the MAM4 implementation of the
nucleation process, described in \refsubsection{nuc:mam4}, is defined in a C++
class named \verb MAMNucleationProcess . A C++ class derived from a base class
is called a {\bf subclass} of that base class, so
\verb MAMNucleationProcess  is a subclass of \verb PrognosticProcess .

To create a C++ implemention for a prognostic process:

\begin{enumerate}
  \item Create a header file that declares your subclass of
        \verb PrognosticProcess . This header file must declare a constructor,
        a destructor, the \verb init  function, and the \verb run  function.
        This file lives in the \verb haero/processes  subdirectory within the
        repository. See \verb haero/processes/MAMNucleationProcess.hpp  for an
        example.
  \item Create a source file containing implementations for the constructor, the
        destructor, the \verb init  functon, and the \verb run  function for
        your subclass. This lives alongside the header file you just created.
        See \verb haero/processes/MAMNucleationProcess.cpp for an example.
        In particular, select the \verb ProcessType  value that reflects the
        proper stage of the aerosol lifecycle for your process.
  \item Add your source file to the set of source files in the
        \verb PROCESS_SOURCES  variable in \verb haero/processes/CMakeLists.txt .
  \item Write one or more tests for your new aerosol process.
        \refchapter{testing} provides extensive details about how to do this.
\end{enumerate}

\subsubsection{Fortran prognostic processes}
\labelsubsubsection{lib:prognostic_f90}

A Fortran prognostic process implementation consists of a Fortran module that
contains \verb init , \verb run , and \verb finalize  subroutines that implement
the same functionality as their C++ counterparts:

\begin{lstlisting}
module <module_name>
  use haero, only: wp, model_t, prognostics_t, atmosphere_t, &
                   diagnostics_t, tendencies_t
  ...
  implicit none
  public :: init, run, finalize

contains

subroutine init(model)
  implicit none

  ! Arguments
  type(model_t), intent(in) :: model

  ...
end subroutine

subroutine run(model, t, dt, prognostics, atmosphere, diagnostics, tendencies)
  implicit none

  ! Arguments
  type(model_t), intent(in)         :: model
  real(wp), value, intent(in)       :: t
  real(wp), value, intent(in)       :: dt
  type(prognostics_t), intent(in)   :: prognostics
  type(atmosphere_t), intent(in)    :: atmosphere
  type(diagnostics_t), intent(in)   :: diagnostics
  type(tendencies_t), intent(inout) :: tendencies

  ...
end subroutine

subroutine finalize(model)
  implicit none

  ! Arguments
  type(model_t), intent(in) :: model

  ...
end subroutine

...

end module
\end{lstlisting}

To implement a prognostic process in Fortran, you create such a module in a
Fortran source file and then declare it as a \verb prognostic_fprocess in the
\verb CMakeLists.txt  file within the \verb haero/processes subdirectory. There
are instructions on how to declare your process in that file.

For example, the Fortran MAM nucleation process is implemented in a Fortran
module named \verb mam_nucleation , implemented in the source file
\verb haero/processes/mam_nucleation.F90 . In \verb haero/processes/CMakeLists.txt ,
it's declared as a Fortran prognostic process the following way:

\begin{lstlisting}
if (HAERO_FORTRAN)
  ...
  prognostic_fprocess(MAMNucleationFProcess NucleationProcess mam_nucleation)
  ...
endif()
\end{lstlisting}

The declaration takes three arguments:

\begin{enumerate}
  \item The name of a C++ class that will be created that exposes the Fortran
        implementation of the process
  \item The C++ enumerated type that identifies what kind of aerosol process
        is being implemented
  \item The name of the Fortran module that implements the process.
\end{enumerate}

The build system automatically generates a C++ class for the Fortran module that
allows the process to be used in a Haero simulation. The name of this C++ class
is important for exposing it to the Haero library.

\subsubsection{Making your prognostic process available to Haero}

So you've implemented your prognostic process in C++ or Fortran. How do you
make it available to the Haero library? There are a few more things you need to
do before Haero can construct a model that includes your new process type:

\begin{enumerate}
  \item Edit the \verb SelectedProcesses  struct in
        \verb haero/selected_processes.hpp  , and add a field to the enumerated
        type that corresponds to the \verb ProcessType  value you selected in
        Step 2 of your implementation procedure above.
  \item Edit the \verb select_prognostic_process  function in
        \verb haero/selected_processes.cpp  to create a new pointer to the C++
        class that implements or wraps your process type. You don't have to
        \verb #include  the C++ header file for your process--it should be
        included for you in the generated file \verb available_processes.hpp .
  \item Update the driver YAML input parser to add an option for a user
        to select your new process.
  \item Update this document with a description of your process in the
        appropriate section of \refchapter{processes}.
\end{enumerate}

Once you've done these things and rebuilt Haero, your new process type is
available for use.

\subsection{The Diagnostic Process Interface}
\labelsubsection{lib:diagnostic_process}

Like a prognostic process, a diagnostic process has three behaviors that must be
implemented in a C++ function or a Fortran subroutine.

\begin{enumerate}
  \item {\bf initialization}: like a prognostic process, a diagnostic process
        can perform whatever work and/or resource allocation is needed during
        initialization. If nothing needs to be done for initialization, its
        function or subroutine body can be empty.
  \item {\bf updating}: the process must know how to update any relevant
        diagnostic variables. The procedure for updating these variables is
        defined by a function or subroutine that provides all prognostic
        variables for the aerosol system as input. The function or subroutine
        that implements this behavior updates the relevant diagnostic variables
        immediately and returns.
  \item {\bf finalization}: the finalization of a diagnostic process is similar
        to that for a prognostic process. If no resources are allocated by the
        process during initialization, the function or subroutine body
        implementing finalization can be empty.
\end{enumerate}

Implementing a diagnostic process is very similar to implementing a prognostic
process. The only difference is that the diagnostic process has an
\verb update  behavior with a different interface from the \verb run  behavior
in a prognostic process.

As in the case of prognostic processes, we use C++'s object-oriented approach to
implement diagnostic processes in C++ and Fortran. This time we derive a C++
class from the \verb DiagnosticProcess  base class, which has following
interface (see \verb haero/process.hpp ):

\begin{lstlisting}
class DiagnosticProcess {
  public:

  // Constructor, called by all DiagnosticProcess subclasses.
  DiagnosticProcess(ProcessType type, const std::string& name):
    type_(type), name_(name) {}

  // Destructor.
  virtual ~DiagnosticProcess() {}

  // Override this method if your aerosol process needs to be initialized
  // with information about the model. The default implementation does nothing.
  virtual void init(const Model& model) {}

  // Override this method to update diagnostic variables at the given time.
  virtual void update(const Model& model, Real t,
                      const Prognostics& prognostics,
                      const Atmosphere& atmosphere,
                      Diagnostics& diagnostics) const = 0;

  // This function accepts the names of diagnostic variables required by this
  // process. These variables include those variables used by the process, as
  // well as variables computed by the process. The process ensures that any
  // Diagnostics object passed to it has storage for these variables. This
  // is usually called inside the constructor of a DiagnosticProcess subclass.
  void set_diag_vars(const std::vector<std::string>& vars,
                     const std::vector<std::string>& aero_vars,
                     const std::vector<std::string>& gas_vars,
                     const std::vector<std::string>& modal_vars);
};
\end{lstlisting}

Everything about this interface is the same as the \verb PrognosticProcess ,
except that

\begin{itemize}
  \item the \verb run  function here is replaced by the \verb update  function
  \item there's a \verb set_diag_vars  function that you can use to express
        which diagnostic variables are required by your process
\end{itemize}

The procedure for implementing a diagnostic process is almost exactly
the same as that for a prognostic process.

\subsubsection{Implementing a diagnostic process in C++}
\labelsubsubsection{lib:diagnostic_cxx}

To create a C++ implemention for a diagnostic process:

\begin{enumerate}
  \item Create a header file that declares your subclass of
        \verb DiagnosticProcess . This header file must declare a constructor,
        a destructor, the \verb init  function, and the \verb run  function.
        This file lives in the \verb haero/processes  subdirectory within the
        repository. See \verb haero/processes/MAMWaterUptakeProcess.hpp  for an
        example.
  \item Create a source file containing implementations for the constructor, the
        destructor, the \verb init  functon, and the \verb run  function for
        your subclass. This lives alongside the header file you just created.
        See \verb haero/processes/MAMWaterUptakeProcess.cpp for an example.
        In particular, select the \verb ProcessType  value that reflects the
        proper stage of the aerosol lifecycle for your process.
  \item If your diagnostic process requires the presence of specific diagnostic
        variables, call the \verb set_diag_vars  function (with the appropriate
        variable names of each type) in the class's constructor.
  \item Add your source file to the set of source files in the
        \verb PROCESS_SOURCES  variable in \verb haero/processes/CMakeLists.txt .
  \item Write one or more tests for your new aerosol process.
        \refchapter{testing} provides extensive details about how to do this.
\end{enumerate}

\subsubsection{Implementing a diagnostic process in Fortran}
\labelsubsubsection{lib:diagnostic_f90}

A Fortran diagnostic process implementation consists of a Fortran module that
contains \verb init , \verb update , and \verb finalize  subroutines that implement
the same functionality as their C++ counterparts:

\begin{lstlisting}
module <module_name>
  use haero, only: wp, model_t, prognostics_t, atmosphere_t, diagnostics_t
  ...
  implicit none
  public :: init, update, finalize

contains

subroutine init(model)
  implicit none

  ! Arguments
  type(model_t), intent(in) :: model

  ...
end subroutine

subroutine update(model, t, prognostics, atmosphere, diagnostics)
  implicit none

  ! Arguments
  type(model_t), intent(in)          :: model
  real(wp), value, intent(in)        :: t
  type(prognostics_t), intent(in)    :: prognostics
  type(atmosphere_t), intent(in)     :: atmosphere
  type(diagnostics_t), intent(inout) :: diagnostics

  ...
end subroutine

subroutine finalize(model)
  implicit none

  ! Arguments
  type(model_t), intent(in) :: model

  ...
end subroutine

...

end module
\end{lstlisting}

To implement a diagnostic process in Fortran, you create such a module in a
Fortran source file and then declare it as a \verb diagnostic_fprocess in the
\verb CMakeLists.txt  file within the \verb haero/processes subdirectory. There
are instructions on how to declare your process in that file.

For example, the Fortran MAM water uptake process is implemented in a Fortran
module named \verb mam_water_uptake , implemented in the source file
\verb haero/processes/mam_water_uptake.F90 . In
\verb haero/processes/CMakeLists.txt , it's declared as a Fortran diagnostic
process the following way:

\begin{lstlisting}
if (HAERO_FORTRAN)
  ...
  diagnostic_fprocess(MAMWaterUptake WaterUptakeProcess mam_water_uptake)
  ...
endif()
\end{lstlisting}

This declaration takes three arguments that have the same meaning as those for
Fortran prognostic processes. As in the case of prognostic processes, the build
system generates a C++ class for the Fortran module.

\subsubsection{Making your diagnostic process available to Haero}

To make Haero aware of your new diagnostic process, you follow similar steps
to those for prognostic processes:

\begin{enumerate}
  \item Edit the \verb SelectedProcesses  struct in
        \verb haero/selected_processes.hpp  , and add a field to the enumerated
        type that corresponds to the \verb ProcessType  value you selected in
        Step 2 of your implementation procedure above.
  \item Edit the \verb select_diagnostic_process  function in
        \verb haero/selected_processes.cpp  to create a new pointer to the C++
        class for your process type.
  \item Update the driver YAML input parser to add an option for a user
        to select your new process.
  \item Update this document with a description of your process in the
        appropriate section of \refchapter{processes}.
\end{enumerate}

It's helpful to look at examples of existing prognostic and diagnostic
processes before you get started on your own. In addition, it often helps to
think about how you might test a process to clarify and test your assumptions.
In the next chapter, we discuss Haero's approach to testing aerosol processes.
