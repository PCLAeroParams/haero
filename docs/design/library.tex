\chapter{The Haero Library}
\labelchapter{library}

In this chapter, we describe the Haero software library itself, and its usage
within an atmospheric model.

\section{Overview}
\labelsection{lib:overview}

Haero is designed to provide a modal aerosol capability to an atmospheric model
written in C++ and/or Fortran. It makes no attempt to describe or evolve any
atmospheric phenomena outside of aerosols. Instead, Haero evolves the state of
aerosols within a modal aerosol model as part of a broader atmospheric
{\bf host model}---a mathematically consistent description of the atmosphere.

To use Haero in your own host model, you write code to interact to construct
a modal aerosol system and invoke aerosol processes on that system. Haero gives
you all the flexibility and control you need to define how the aerosol processes
couple with and interoperate with the other processes in the host model. In this
sense, Haero is a set of building blocks you can use to construct the most
appropriate modal aerosol representation for your host model.

\subsection{Aerosol Systems}
\labelsubsection{lib:systems}

Haero's representation of aerosols relies on a set of elementary data structures
that define the assumptions underlying a specific modal aerosol system. These
elements are:

\begin{itemize}
  \item An {\bf Aerosol Model}: the definition of a specific modal aerosol
        system to be simulated
  \item {\bf Modes}: statistical representations of aerosol particle populations
        organized by particle size
  \item {\bf Species}: aerosol and gas molecules of interest. Each aerosol
        species belongs to a single aerosol mode and is tracked by mass and
        number.
\end{itemize}

These entities define the aerosol system of interest in Haero, and provide
any related {\bf metadata} needed to make decisions about how an aerosol
processes does its work.

\subsection{Aerosol State Data}
\labelsubsection{lib:state}

Haero deals with two distinct types of state variables:

\begin{itemize}
  \item {\bf Prognostic variables}: variables that are evolved in time according
        to a system of differential equations
  \item {\bf Diagnostic variables}: variables that are algebraically related to
        other variables, whether those variables are prognostic or diagnostic
\end{itemize}

Prognostic variables are quantities that possess an initial state and are
evolved forward in time by their {\bf tendencies} (time derivatives). It is
not possible to construct the value of a prognostic variable at time $t$ without
an initial condition at some time $t_0$ and a tendency defined over the period
$\left[t_0, t\right]$.

The concept of a ``diagnostic'' variable is more general than its name suggests.
The word "diagnostic" suggests that the variable is used only as an indicator
by a human attempting to ``diagnose'' some atmospheric condition. In fact, a
diagnostic variable can be any variable whose state can be constructed at any
instant in time, using only the relevant prognostic variables.

Haero's aerosol state data lives in multi-dimensional arrays within ``smart
containers'' called \verb Prognostics  and \verb Diagnostics , whose names
indicate the types of variables they store. These arrays are stored in
\verb View  data structures provided by the Kokkos C++ library. Aerosol state
data is allocated in C++, but available for use in Fortran for implementing
aerosol processes or for using Haero from within a Fortran host model.

\subsection{Aerosol Processes}
\labelsubsection{lib:processes}

The aerosol ``life cycle'' consists of a set of complicated physical processes
involving many participants, with a wide range of length and time scales. These
different scales demand a degree of flexibility in how we evaluate changes to
the state of an aerosol system. For example, we expect to be able to resolve
processes whose time scale is similar to or larger than the time scale for
convection in the atmosphere, whereas processes with faster time scales must be
treated in some special way that accommodates a relaxation or equilibration
process.

Haero provides data structures for constructing two distinct types of aerosol
processes:

\begin{itemize}
  \item A {\bf prognostic process} accepts a set of prognostic and diagnostic
        variables as input, and computes as output one or more tendencies for a
        corresponding set of prognostic variables. It does not make any changes
        to any of its inputs.
  \item A {\bf diagnostic process} accepts a set of prognostic variables as
        input, and updates one or more diagnostic variables in place so that
        these variables are consistent with the prognostic variables.
\end{itemize}

A process consists of a set of parameterizations that encode simplifying
assumptions about a specific stage of the aerosol life cycle into an algorithm
that computes the relevant quantities of interest. The processes provided by
Haero, and their various parameterizations, are described in \refchapter{processes}.

These processes are the true assets of the Haero library. They can be
implemented in C++, in Fortran, or in both. This allows aerosol researchers to
make their latest parameterizations available in the Haero library, while
providing software engineers with a ``future-proof'' environment for optimizing
these and other parameterizations for DOE's Leadership Class Facilities.

That's an orbit-level view of the Haero library. Now let's take a closer look at
each of these aspects.

\section{Aerosol Systems in Haero}
\labelsection{lib:systems}

To model a specific aerosol system in Haero, we must answer some questions:

\begin{itemize}
  \item What modes are required to accurately characterize the distribution of
        interesting particle sizes?
  \item What species are present in the system, and in what modes are they
        allowed to appear?
  \item How many atmospheric columns are needed to model the system?
  \item How many vertical levels are needed to resolve the profile of aerosols
        in the system?
  \item Which physical processes are relevant to a simulation of interest?
        Should any processes be excluded, to answer a specific question about
        how the processes interact with each other, or because they are not
        signficant for the system?
\end{itemize}

Each of these decisions greatly affects the nature of the model---systems with
different answers to these questions will have very different behavior. When we
define a Haero simulation, we encode the answers to these decisions in an
{\bf aerosol model} variable.

What do we mean by an ``aerosol model'', exactly? One can think about it in a
few different ways.

\begin{itemize}
  \item An aerosol model specifies the physics (or the approximations to the
        physics, if you like) represented by an aerosol simulation.
  \item An aerosol model stores a set of ``global variables'' that govern the
        behavior for the simulation of a single aerosol system.
  \item Every aerosol system is described by exactly one aerosol model.
  \item The aerosol model encodes the assumptions made about an aerosol system's
        representation. It does not define the state of that system at any given
        time. In this sense, all of its information is ``timeless''.
\end{itemize}

\subsection{The Model Type}
\labelsubsection{lib:model}

In Haero, an aerosol model is defined by the \verb Model  type, defined within
the \verb haero  namespace. Interfaces to this type are provided in both C++ and
Fortran.

Below is an abbreviated look at the \verb Model  C++ class. The source code for
this class can be found in the \verb haero/model.hpp  and
\verb haero/model.cpp files within the repository. Reading through this class,
you'll see references to various other data structures. We describe these data
structures in subsequent sections.

\lstset{language=[11]{c++}}
\begin{lstlisting}
class Model final {
  public:

  // Constructor -- creates a new model given all relevant data.
  Model(const Parameterizations& parameterizations,
        const std::vector<Mode>& aerosol_modes,
        const std::vector<Species>& aerosol_species,
        const std::map<std::string, std::vector<std::string> >& mode_species,
        const std::vector<Species>& gas_species,
        int num_columns,
        int num_levels);

  // Creates a set of prognostic variables for use with this model.
  Prognostics* create_prognostics() const;

  // Creates a set of diagnostic variables for use with this model.
  Diagnostics* create_diagnostics() const;

  // Runs the (prognostic) aerosol process of the given type, computing any
  // relevant tendencies.
  void run_process(ProcessType type,
                   Real t, Real dt,
                   const Prognostics& prognostics,
                   const Diagnostics& diagnostics,
                   Tendencies& tendencies);

  // Runs the (diagnostic) aerosol process of the given type, updating all
  // relevant diagnostic variables in place.
  void update_diagnostics(ProcessType type, Real t,
                          const Prognostics& prognostics,
                          Diagnostics& diagnostics);

  // Returns the parameterizations associated with this aerosol model.
  const Parametrizations& parametrizations() const;

  // Returns the list of modes for the context.
  const std::vector<Mode>& modes() const;

  // Returns the list of aerosol species for the context.
  const std::vector<Species>& aero_species() const;

  // Returns the list of gas species for the context.
  const std::vector<Species>& gas_species() const;

  // Returns the number of vertical atmospheric columns in a simulation
  // associated with this context.
  int num_columns() const;

  // Returns the number of vertical levels (cells) in each atmospheric column.
  int num_levels() const;
};
\end{lstlisting}

In C++, you can create as many \verb Model  variables as you like, though
there's usually no reason to do so, unless you're running an ensemble of
simulations whose underlying assumptions differ beyond their initial states.

Haero's Fortran interface provides a \verb model_t  derived type with a subset
of the information available to the C++ \verb Model  type. While the Fortran
interface doesn't have ``feature parity'' with its C++ counterpart, we argue
that it provides ample information for implementing aerosol processes in
Fortran.

\lstset{language=[03]{fortran}}
\begin{lstlisting}
type :: model_t
  ! The aerosol modes in the model, in indexed order.
  type(mode_t), dimension(:), allocatable :: modes
  ! The number of modes in the model. Equal to size(modes).
  integer :: num_modes
  ! The number of actual species that exist within each mode.
  integer, dimension(:), allocatable :: num_mode_species
  ! The aerosol species within each mode. Indexed as (mode, species).
  type(species_t), dimension(:,:), allocatable :: aero_species
  ! The gas species in the model.
  type(species_t), dimension(:), allocatable :: gas_species
  ! The number of columns in the model.
  integer :: num_columns
  ! The number of vertical levels in each column.
  integer :: num_levels
end type
\end{lstlisting}

In Fortran, a single global \verb model_t  variable, \verb model , is provided
within the \verb haero  module. This variable is automatically populated with
data by Haero before any work is done, so there's no need to create it or
modify it yourself. {\em Do not attempt to change any data within
this global variable}.

Because the model definition is provided as a global variable, only one instance
of an aerosol model is available to Fortran implementations of aerosol processes.

\subsection{The Mode Type}
\labelsubsection{lib:modes}

We've seen how the dynamics of aerosols can be represented mathematically
by evolution equations for moments of modal distribution functions. Modes
simplify the description of aerosol particles in terms of their size: instead of
representing a population of particles with a distribution function
$n(V_p, \vec{x}, t)$ that varies continuously with the size of the particle, we
introduced $M$ discrete modes and declared that these modes partition the
population of aerosol particles in the sense of the modal assumption as given
by \refeq{modal_n}.

The essential information in a mode is the range of particle sizes it
encompasses, $[D_{\min}, D_{\max}]$, and its geometric standard deviation,
$\sigma_g$. In Haero's C and C++ interfaces,
we represent an aerosol mode with the \verb|Mode| struct:

\lstset{language=[11]{c++}}
\begin{lstlisting}
struct Mode {
  std::string name;  // a unique identifier for the mode
  Real min_diameter; // the mode's minimum particle diameter
  Real max_diameter; // the mode's maximum particle diameter
  Real mean_std_dev; // the geometric mean standard deviation for the mode
};
\end{lstlisting}

Haero's Fortran interface offers a \verb mode_t  data structure, equivalent to
the C++ \verb Mode  class. This data structure is defined in the \verb haero  Fortran
module:

\lstset{language=[03]{fortran}}
\begin{lstlisting}
type :: mode_t
  ! Mode name
  character(len=:), allocatable :: name
  ! Minimum particle diameter
  real(wp) :: min_diameter
  ! Maximum particle diameter
  real(wp) :: max_diameter
  ! Geometric mean standard deviation
  real(wp) :: mean_std_dev
end type
\end{lstlisting}

In principle, a Haero calculation can support any number of modes, but care
must be taken to ensure that the modal assumptions remain valid, and that
the parametrizations selected can accommodate the given modes.

\subsection{The Species Type}
\labelsubsection{lib:species}

Each aerosol mode consists of one or more particle species. Additionally,
gas particles also come in different species. Both aerosol particles and
gas particles have physical properties that are described by the
\verb Species  data type.

A particle species is a specifically-identified molecular assembly with
a number of relevant physical properties. The fundamental description of a
species includes

\begin{itemize}
  \item a symbolic name (e.g. \verb SO4 , for sulfate)
  \item a descriptive name (e.g. \verb "sulfate" )
  \item information about the chemical properties of the species
\end{itemize}

In C++, we represent this information in the following way:

\lstset{language=[11]{c++}}
\begin{lstlisting}
struct Species {
  std::string name;          // full species name
  std::string symbol;        // abbreviated symbolic name
  Real molecular weight;     // molecular weight [g/mol]
  Real crystalization_point; // crystalization point [?]
  Real deliquescence_point;  // deliquenscence point [?]
};
\end{lstlisting}

In Fortran, a species is defined by the following derived type:
\lstset{language=[03]{fortran}}
\begin{lstlisting}
type :: species_t
  ! Species name
  character(len=:), allocatable :: name
  ! Species symbol (abbreviation)
  character(len=:), allocatable :: symbol
  ! Molecular weight [g/mol]
  real(wp) :: molecular_wt
  ! Crystalization point [?]
  real(wp) :: crystal_pt
  ! Deliquenscence point [?]
  real(wp) :: deliques_pt
end type
\end{lstlisting}

\section{State Variables in Haero}
\labelsection{lib:state}

Once a model variable has been created that defines an aerosol system, you can
create state variables for that system. The state of a system is defined by the
following prognostic variables:

\begin{itemize}
  \item {\bf modal number densities}: the total number of particles per cubic
        meter in each mode
  \item {\bf aerosol modal mix fractions}: the fraction of a mode occupied
        by each aerosol species present within that mode
  \item {\bf gas mole fractions}: the number of moles of each gas species per
        mole of air
\end{itemize}

In addition, the model possesses a set of diagnostic variables that depend on
its selected aerosol processes (which are discussed in a later section).

How does one create a set of state variables given a model variable? Recall that
the \verb Model  C++ class provides the following two functions, which you can
call directly yourself, given a pointer to a C++ variable called \verb model :

\begin{itemize}
  \item \verb model->create_prognostics()  : returns a pointer to a C++
    \verb Prognostics  container
  \item \verb model->create_diagnostics()  : returns a pointer to a C++
    \verb Diagnostics  container
\end{itemize}

These functions don't take any parameters---they just use the information within
the model variable.

By the way, you don't always have to call these functions yourself. State
variables are automatically created if you're using the Haero driver or
implementing a parameterization in C++ or Fortran. However, if you're using
Haero within your own host model, or if you're writing a unit test for your
parameterization, you must call these functions to obtain containers for your
aerosol model's state data.

The \verb Prognostics  and \verb Diagnostics  containers store prognostic and
diagnostic state data, respectively, in multidimensional arrays allocated in C++
but made available to both C++ and Fortran. The data for each array is stored
within a Kokkos View.

\subsection*{Kokkos Views}
\labelsubsection{lib:views}

The C++ programming language has lots of features, but remarkably it includes no
mechanism for allocating multidimensional arrays at runtime. The Kokkos C++
library fills this gap by providing a data structure called a \verb View . A
\verb View  is essentially an interface that allows a C++ programmer to treat a
chunk of memory like a multidimensional array.

A \verb View  has a rank and a set of dimensions, just like an allocatable
Fortran array. You access a \verb View  in the same way that you'd access a
Fortran array, except that C++ uses row-major indexing instead of Fortran's
column-major indexing. So for a rank-3 view \verb f  that you access in C++
as \verb f(i,j,k) , you would access the corresponding array in Fortran as
\verb f(k,j,i) .

{\em TODO: try to make some sense of packs}

Because Haero is concerned with arrays having very specific dimensions, we
define some named types that correspond to views/arrays that span specific
spaces:

\begin{table}[htbp]
\centering
\caption{Named C++ View Types}
\label{tab:viewtypes}
\begin{tabular}{|l|l|p{6cm}|l|l|}
  \toprule
  View Name & Rank & Description & C++ & Fortran \\
  \midrule
  \verb ColumnView  & 2 & Maps a column $i$ and a vertical level $k$ to a pack & \verb v(i,k)  & \verb v(k,i) \\
  \verb ColumnSpeciesView  & 3 & Maps a column $i$, a vertical level $k$, and a species $s$ to a pack & \verb v(i,k,s)  & \verb v(s,k,i) \\
  \verb ModalColumnView & 3 & Maps a mode index $m$, a column $i$, and a vertical level $k$ to a pack & \verb v(i,k,s)  & \verb v(s,k,i) \\
  \bottomrule
\end{tabular}
\end{table}

Both the \verb Prognostics  and \verb Diagnostics  containers described below
make use of these named types.

\subsection{Prognostics Type}
\labelsubsection{lib:prognostics}

The \verb Prognostics  C++ class provides access to the prognostic variables
that define aerosols in a modal description. Here's the C++ class interface
(abbreviated for brevity---see the full interface in \verb haero/prognostics.hpp ):

\lstset{language=[11]{c++}}
\begin{lstlisting}
class Prognostics final {
  public:
  // Returns the number of aerosol modes in the system.
  int num_aerosol_modes() const;

  // Returns the number of aerosol species in the mode with the given index.
  int num_aerosol_species(int mode_index) const;

  // Returns the number of gas species in the system.
  int num_gas_species() const;

  // Returns the number of independent atmospheric columns in the system.
  int num_columns() const;

  // Returns the number of vertical levels per column in the system.
  int num_levels() const;

  // Returns the view storing interstitial aerosol species mixing fraction data
  // for the mode with the given index.
  const ColumnSpeciesView& interstitial_aerosols(int mode_index) const;

  // Returns the view storing cloud-borne aerosol species mixing fraction data
  // for the mode with the given index.
  const ColumnSpeciesView& cloudborne_aerosols(int mode_index) const;

  // Returns the view storing the mole fractions of gas species in the state.
  const ColumnSpeciesView& gas_mole_fractions() const;

  // Returns the view storing the modal number densities.
  const ModalColumnView& modal_num_densities() const;

  // Scales the given set of tendencies and adds it into this state, summing
  // the values of the prognostic variables in place.
  void scale_and_add(Real scale_factor, const Tendencies& tendencies);
};
\end{lstlisting}

Typically, you never modify a \verb Prognostics  variable directly. Instead, you
compute a set of tendencies (in a \verb Tendencies  variable, which is very
similar to a \verb Prognostics  variable) and accumulate them into your
\verb Prognostics  variable by calling \verb scale_and_add .

The Fortran version of the \verb Prognostics  type is similar, and offers
access to Fortran multidimensional arrays instead of C++ views. For cleaner
syntax, this type uses bound procedures to return pointers to its arrays.

\lstset{language=[03]{fortran}}
\begin{lstlisting}
  type :: prognostics_t
  contains
    ! Access to interstitial aerosol mix fractions array
    procedure :: interstitial_aerosols => p_int_aero_mix_frac
    ! Access to cloudborne aerosol mix fractions array
    procedure :: cloudborne_aerosols => p_cld_aero_mix_frac
    ! Access to gas mole fractions array
    procedure :: gas_mole_fractions => p_gas_mole_frac
    ! Access to modal number densities array
    procedure :: modal_num_densities => p_modal_num_densities
  end type

  ! Provides access to the interstitial aerosol mixing fractions array
  ! for the given mode in the given prognostics object p.
  function p_int_aero_mix_frac(p, mode) result(retval)
    class(prognostics_t), intent(in)  :: p
    integer(c_int), value, intent(in) :: mode
    real(c_real), pointer, dimension(:,:,:) :: retval
  end function

  ! Provides access to the cloud-borne aerosol mixing fractions array
  ! for the given mode in the given prognostics object p.
  function p_cld_aero_mix_frac(p, mode) result(retval)
    class(prognostics_t), intent(in)  :: p
    integer(c_int), value, intent(in) :: mode
    real(c_real), pointer, dimension(:,:,:) :: retval
  end function

  ! Provides access to the gas mole fractions array for the given
  ! prognostics object p.
  function p_gas_mole_frac(p) result(retval)
    use iso_c_binding, only: c_ptr, c_int
    class(prognostics_t), intent(in) :: p
    real(c_real), pointer, dimension(:,:,:) :: retval
  end function

  ! Provides access to the modal number fractions array for the given
  ! prognostics object p.
  function p_modal_num_densities(p) result(retval)
    use iso_c_binding, only: c_ptr, c_int
    class(prognostics_t), intent(in) :: p
    real(c_real), pointer, dimension(:,:,:) :: retval
  end function
\end{lstlisting}

\subsection{Diagnostics Type}
\labelsubsection{lib:diagnostics}

The \verb Diagnostics  C++ class stores a dynamically-determined set of
diagnostic variables that correspond to the specific parameterizations available
to the aerosol model that created it.

\lstset{language=[11]c++}
\begin{lstlisting}
class Diagnostics final {
  public:
  // Returns the number of aerosol modes in the system.
  int num_aerosol_modes() const;

  // Returns the number of aerosol species in the mode with the given index.
  int num_aerosol_species(int mode_index) const;

  // Returns the number of gas species in the system.
  int num_gas_species() const;

  // Returns the number of independent atmospheric columns in the system.
  int num_columns() const;

  // Returns the number of vertical levels per column in the system.
  int num_levels() const;

  // Returns true if the given (non-modal) variable exists within this object,
  // false otherwise.
  bool has_var(const std::string& name) const;

  // Returns the view storing the diagnostic variable with the given name.
  // If the variable does not yet exist, this throws an exception.
  ColumnView& var(const std::string& name);

  // Returns true if the given modal aerosol variable exists within this object,
  // false otherwise.
  bool has_aerosol_var(const std::string& name) const;

  // Returns the view storing the modal aerosol diagnostic variable with the
  // given name and mode index. If the variable does not yet exist, this throws
  // an exception.
  ColumnSpeciesView& aerosol_var(const std::string& name, int mode_index);

  // Returns true if a variable defined for each gas species exists within
  // this object with the given name, false otherwise.
  bool has_gas_var(const std::string& name) const;

  // Returns the view storing a diagnostic variable, defined for each gas
  // species, with the given name. If the variable does not yet exist, this
  // throws an exception.
  ColumnSpeciesView& gas_var(const std::string& name);

  // Returns true if the given modal variable exists within this object,
  // false otherwise.
  bool has_modal_var(const std::string& name) const;

  // Returns the view storing the mode-specific diagnostic variable with the
  // given name. If the variable does not yet exist, this throws an exception.
  // @param [in] name The name of the diagnostic variable.
  ModalColumnView& modal_var(const std::string& name);
};
\end{lstlisting}

The Fortran version of \verb Diagnostics , like its \verb Prognostics  counterpart,
uses bound procedures to provide access to its array data:

\lstset{language=[03]{fortran}}
\begin{lstlisting}
  type :: diagnostics_t
  contains
    procedure :: has_var => d_has_var
    procedure :: var => d_var
    procedure :: has_aerosol_var => d_has_aerosol_var
    procedure :: aerosol_var => d_aerosol_var
    procedure :: has_gas_var => d_has_gas_var
    procedure :: gas_var => d_gas_var
    procedure :: has_modal_var => d_has_modal_var
    procedure :: modal_var => d_modal_var
  end type

  ! Returns true if the given diagnostics object d contains a (non-modal)
  ! variable with the given name, false otherwise.
  function d_has_var(d, name) result(retval)
    use iso_c_binding, only: c_ptr, c_bool
    class(diagnostics_t), intent(in) :: d
    character(len=*), intent(in) :: name
    logical(c_bool) :: retval
  end function

  ! Provides access to the given (non-modal) variable in the given
  ! diagnostics object d.
  function d_var(d, name) result(retval)
    class(diagnostics_t), intent(in)  :: d
    character(len=*), intent(in) :: name
    real(wp), dimension(:,:), pointer :: retval
  end function

  ! Returns true if the given diagnostics object d contains a modal aerosol
  ! variable with the given name, false otherwise.
  function d_has_aerosol_var(d, name, mode) result(retval)
    use iso_c_binding, only: c_ptr, c_char, c_bool, c_int
    class(diagnostics_t), intent(in) :: d
    character(len=*), intent(in) :: name
    integer(c_int), intent(in) :: mode
    logical(c_bool) :: retval
  end function

  ! Provides access to the given (non-modal) variable in the given
  ! diagnostics object d.
  function d_aerosol_var(d, name, mode) result(retval)
    class(diagnostics_t), intent(in)  :: d
    character(len=*), intent(in) :: name
    integer(c_int), intent(in) :: mode
    real(wp), dimension(:,:,:), pointer :: retval
  end function

  ! Returns true if the given diagnostics object d contains a (non-modal)
  ! variable with the given name, false otherwise.
  function d_has_gas_var(d, name) result(retval)
    use iso_c_binding, only: c_ptr, c_bool
    class(diagnostics_t), intent(in) :: d
    character(len=*), intent(in) :: name
    logical(c_bool) :: retval
  end function

  ! Provides access to the given (non-modal) variable in the given
  ! diagnostics object d.
  function d_gas_var(d, name) result(retval)
    class(diagnostics_t), intent(in)  :: d
    character(len=*), intent(in) :: name
    real(wp), dimension(:,:,:), pointer :: retval
  end function

  ! Returns true if the given diagnostics object d contains a modal
  ! variable with the given name, false otherwise.
  function d_has_modal_var(d, name) result(retval)
    use iso_c_binding, only: c_ptr, c_bool
    class(diagnostics_t), intent(in) :: d
    character(len=*), intent(in) :: name
    logical(c_bool) :: retval
  end function

  ! Provides access to the given modal variable in the given
  ! diagnostics object d.
  function d_modal_var(d, name) result(retval)
    class(diagnostics_t), intent(in)  :: d
    character(len=*), intent(in) :: name
    real(wp), dimension(:,:,:), pointer :: retval
  end function
\end{lstlisting}

At this point, you might wonder how a \verb Diagnostics  variable knows which
variables it needs. In fact, the \verb Diagnostics  class provides functions for
creating variables that it needs. The C++ \verb Model  variable used to create
a \verb Diagnostics  variable knows this information, and automatically calls
these functions for you.

For examples of how these \verb Prognostics  and \verb Diagnostics  types are
used in practice, take a look at one of the existing aerosol process
implementations.

\section{Aerosol Processes in Haero}
\labelsection{lib:processes}

The aerosol life cycle consists of several important and distinct physical
processes. As we mentioned in \refsubsection{lib:processes}, there are
{\bf prognostic processes}, which compute tendencies for prognostic variables,
and there are {\bf diagnostic processes}, which update diagnostic variables
in place.

Haero offers data structures that make it very easy to implement these two types
of processes. Because the structure of a given process doesn't depend on the
details of its implementation, we can define abstract interfaces for these
processes. These abstract interfaces simplify the development of a process---
instead of designing a new process from the ground up every time you want to
add new functionality to Haero, you can simply implement a small number of
functions (or subroutines) that define the behavior of a process, and let the
Haero library handle the details of how these processes are created and used.

For detailed descriptions of the specific processes provided by Haero, take a
look at \refchapter{processes}. You can find examples of source code for
Haero's processes in the \verb haero/processes  subdirectory.

\subsection{The Prognostic Process Interface}
\labelsubsection{lib:prognostic_process}

A prognostic process has three behaviors which must be defined by any
implementation. Each of these behaviors is implemented in a C++ function or
a Fortran subroutine.

\begin{enumerate}
  \item {\bf initialization}: the process must be able to allocate any resources
        it needs to do its work. These resources include temporary work arrays,
        look-up tables, and quantities that need to be precomputed. State data
        is not managed by processes, so it's not included in process
        initialization. If nothing needs to be done for initialization, its
        function or subroutine body can be empty.
  \item {\bf running}: the process must know how to ``run''. In other words, it
        must define a procedure for computing tendencies for a relevant set of
        prognostic variables given their current values, and the current values
        of any diagnostic variables. The function or subroutine that implements
        this behavior does not apply these tendencies to any prognostic
        variables---it simply computes the tendencies and returns.
  \item {\bf finalization}: at the end of a simulation program, when the aerosol
        system is destroyed, the process must free all resources it allocated
        in its initialization. If no resources are allocated, the function or
        subroutine body implementing finalization can be empty.
\end{enumerate}

Haero provides an object-oriented approach for implementing a process in terms
of this simple interface. In an object-oriented approach, an abstract interface
is encoded in a ``base class''---a data type that declares the necessary
functions and subroutines. Then any implementation of this interface is defined
in a data type ``derived'' from that base class.

Haero uses the object-oriented features of C++ for process development. All
prognostic process implementations are derived from a C++ base class called
\verb PrognosticProcess . This is true regardless of whether you implement the
process using C++ or Fortran.

The \verb PrognosticProcess  provides the following interface (see
\verb haero/process.hpp  for more details):

\lstset{language=[11]{c++}}
\begin{lstlisting}
class PrognosticProcess {
  public:

  // Constructor, called by all PrognosticProcess subclasses.
  PrognosticProcess(ProcessType type, const std::string& name):
    type_(type), name_(name) {}

  // Destructor.
  virtual ~PrognosticProcess() {}

  // Override this method if your aerosol process needs to be initialized
  // with information about the model. The default implementation does nothing.
  virtual void init(const Model& model) {}

  // Override this method to implement the aerosol process using the specific
  // parameterization for the subclass.
  virtual void run(const Model& model,
                   Real t, Real dt,
                   const Prognostics& prognostics,
                   const Diagnostics& diagnostics,
                   Tendencies& tendencies) const = 0;
};
\end{lstlisting}

In addition to the ``constructor'' function used to create an instance of a
\verb PrognosticProcess  variables, this interface declares three functions
(\verb init , \verb run , and the destructor function \verb \~PrognosticProcess )
that correspond to the three behaviors described above.

The constructor accepts a process type that indicates what stage of the aerosol
life cycle it represents. A \verb ProcessType  data structure is an
``enumerated type'' that enumerates the various stages:

\begin{lstlisting}
// This enumerated type lists all relevant physical aerosol processes.
enum ProcessType {
  ActivationProcess,
  CloudBorneWetRemovalProcess,
  CoagulationProcess,
  CondensationProcess,
  DryDepositionProcess,
  EmissionsProcess,
  InterstitialWetRemovalProcess,
  NucleationProcess,
  ResuspensionProcess,
  WaterUptakeProcess
};
\end{lstlisting}

Let's explore how we might implement a prognostic aerosol process in C++ and in
Fortran. Here we describe only the steps needed to implement the process itself.
You must also testing your process to make sure it behaves the way you think it
does! The procedure for testing an aerosol process is described in
\refchapter{testing}.

\subsubsection{C++ prognostic processes}
\labelsubsubsection{lib:prognostic_cxx}

In C++, all you have to do in order to implement a prognostic process is to
define a class with a specific name, derived from the
\verb PrognosticProcess  base class. For example, the MAM4 implementation of the
nucleation process, described in \refsubsection{nuc:mam4}, is defined in a C++
class named \verb MAM4NucleationProcess . A C++ class derived from a base class
is called a {\bf subclass} of that base class, so
\verb MAM4NucleationProcess  is a subclass of \verb PrognosticProcess .

To create a C++ implemention for a prognostic process:

\begin{enumerate}
  \item Create a header file that declares your subclass of
        \verb PrognosticProcess . This header file must declare a constructor,
        a destructor, the \verb init  function, and the \verb run  function.
        This file lives in the \verb haero/processes  subdirectory within the
        repository. See \verb haero/processes/MAM4NucleationProcess.hpp  for an
        example.
  \item Create a source file containing implementations for the constructor, the
        destructor, the \verb init  functon, and the \verb run  function for
        your subclass. This lives alongside the header file you just created.
        See \verb haero/processes/MAM4NucleationProcess.cpp for an example.
        In particular, select the \verb ProcessType  value that reflects the
        proper stage of the aerosol lifecycle for your process.
  \item Add your source file to the set of source files in the
        \verb PROCESS_SOURCES  variable in \verb haero/processes/CMakeLists.txt .
  \item Write one or more tests for your new aerosol process.
        \refchapter{testing} provides extensive details about how to do this.
\end{enumerate}

\subsubsection{Fortran prognostic processes}
\labelsubsubsection{lib:prognostic_f90}

A Fortran prognostic process implementation consists of a C++ class derived
from the \verb FPrognosticProcess  base class. Here, your C++ subclass is a
very thin wrapper around three Fortran subroutines that live in their own
module. For an example of how this looks in practice, take a look at the
\verb MAM4NucleationFProcess  defined in the following files:

\begin{itemize}
  \item \verb haero/processes/MAM4NucleationFProcess.hpp : the C++ wrapper class
        declaration
  \item \verb haero/processes/MAM4NucleationFProcess.cpp : the C++ wrapper class
        implementation, which calls the subroutines in the associated
        Fortran module. This source file must declare the names of the Fortran
        subroutines in an {\verb extern "C"} block in order for them to be
        visible to the C++ compiler.
  \item \verb haero/processes/mam4_nucleation.F90 : the Fortran submodule, which
        defines the three subroutines called by the C++ wrapper class. These
        subroutines must be declared with the {\verb bind(c) } attribute, and
        must have the same name as those declared in the {\verb extern "C"}
        block in the C++ wrapper class implementation.
\end{itemize}

In other words, an aerosol process implemented in Fortran must have a C++ class
that calls a set of Fortran subroutines. The \verb FPrognosticProcess  C++ class
takes care of most of the work needed for C++ and Fortran to communicate with
each other---all you have to do is supply the Fortran subroutines in a module,
and declare these subroutines in your class implementation.

In this sense, the procedure for creating a Fortran implementation of an aerosol
process is very similar to that for a C++ implementation:

\begin{enumerate}
  \item Create a header file that declares your subclass of
        \verb FPrognosticProcess . Unlike a C++ implementation, this subclass
        only needs a constructor function---the rest of the interface is handled
        by logic in the \verb FPrognosticProcess  class. Like a C++
        implementation, this header file lives in the
        \verb haero/processes  subdirectory within the repository.
  \item Create a Fortran module in which you define three subroutines that
        implement the \verb init , \verb run , and \verb finalize  behaviors
        for your process. Make sure these subroutines are public, and declare
        them with the \verb bind(c)  attribute to make them accessible to C++.
        This module lives in \verb haero/processes  with your C++ header file.
  \item Create a source that contains an implementation for the constructor
        function you declared in the header file above. In this constructor,
        you must call the constructor for the \verb FPrognosticProcess  class.
        The arguments to this constructor include the type and name of the
        process, and the three Fortran subroutines you defined in your module.
        behaviors. These subroutines must be declared in an {\verb extern "C"}
        block within this file. The source file lives alongside the header file
        and the Fortran module you created.
  \item Add your C++ source file and Fortran module to the set of source files
        in the \verb PROCESS_SOURCES  variable in
        \verb haero/processes/CMakeLists.txt .
  \item Write one or more tests for your new aerosol process.
\end{enumerate}

\subsubsection{Making your prognostic process available to Haero}

So you've implemented your prognostic process in C++ or Fortran. How do you
make it available to the Haero library? There are a few more things you need to
do before Haero can construct a model that includes your new process type:

\begin{enumerate}
  \item Edit the \verb SelectedProcesses  struct in
        \verb haero/selected_processes.hpp  , and add a field to the enumerated
        type that corresponds to the \verb ProcessType  value you selected in
        Step 2 of your implementation procedure above.
  \item Edit the \verb select_prognostic_process  function in
        \verb haero/selected_processes.cpp  to create a new pointer to your
        process type.
  \item Update the driver YAML input parser to add an option for a user
        to select your new process.
  \item Update this document with a description of your process in the
        appropriate section of \refchapter{processes}.
\end{enumerate}

Once you've done these things and rebuilt Haero, your new process type is
available for use.

\subsection{The Diagnostic Process Interface}
\labelsubsection{lib:diagnostic_process}

Like a prognostic process, a diagnostic process has three behaviors that must be
implemented in a C++ function or a Fortran subroutine.

\begin{enumerate}
  \item {\bf initialization}: like a prognostic process, a diagnostic process
        can perform whatever work and/or resource allocation is needed during
        initialization. If nothing needs to be done for initialization, its
        function or subroutine body can be empty.
  \item {\bf updating}: the process must know how to update any relevant
        diagnostic variables. The procedure for updating these variables is
        defined by a function or subroutine that provides all prognostic
        variables for the aerosol system as input. The function or subroutine
        that implements this behavior updates the relevant diagnostic variables
        immediately and returns.
  \item {\bf finalization}: the finalization of a diagnostic process is similar
        to that for a prognostic process. If no resources are allocated by the
        process during initialization, the function or subroutine body
        implementing finalization can be empty.
\end{enumerate}

Implementing a diagnostic process is very similar to implementing a prognostic
process. The only difference is that the diagnostic process has an
\verb update  behavior with a different interface from the \verb run  behavior
in a prognostic process.

As in the case of prognostic processes, we use C++'s object-oriented approach to
implement diagnostic processes in C++ and Fortran. This time we derive a C++
class from the \verb DiagnosticProcess  base class, which has following
interface (see \verb haero/process.hpp ):

\begin{lstlisting}
class DiagnosticProcess {
  public:

  // Constructor, called by all DiagnosticProcess subclasses.
  DiagnosticProcess(ProcessType type, const std::string& name):
    type_(type), name_(name) {}

  // Destructor.
  virtual ~DiagnosticProcess() {}

  // Override this method if your aerosol process needs to be initialized
  // with information about the model. The default implementation does nothing.
  virtual void init(const Model& model) {}

  // Override this method to update diagnostic variables at the given time.
  virtual void update(const Model& model, Real t,
                      const Prognostics& prognostics,
                      Diagnostics& diagnostics) const = 0;

  // This function accepts the names of diagnostic variables required by this
  // process. These variables include those variables used by the process, as
  // well as variables computed by the process. The process ensures that any
  // Diagnostics object passed to it has storage for these variables. This
  // is usually called inside the constructor of a DiagnosticProcess subclass.
  void set_diag_vars(const std::vector<std::string>& vars,
                     const std::vector<std::string>& aero_vars,
                     const std::vector<std::string>& gas_vars,
                     const std::vector<std::string>& modal_vars);
};
\end{lstlisting}

Everything about this interface is the same as the \verb PrognosticProcess ,
except that

\begin{itemize}
  \item the \verb run  function here is replaced by the \verb update  function
  \item there's a \verb set_diag_vars  function that you can use to express
        which diagnostic variables are required by your process
\end{itemize}

The procedure for implementing a diagnostic process is almost exactly
the same as that for a prognostic process.

\subsubsection{Implementing a diagnostic process in C++}
\labelsubsubsection{lib:diagnostic_cxx}

To create a C++ implemention for a diagnostic process:

\begin{enumerate}
  \item Create a header file that declares your subclass of
        \verb DiagnosticProcess . This header file must declare a constructor,
        a destructor, the \verb init  function, and the \verb run  function.
        This file lives in the \verb haero/processes  subdirectory within the
        repository. See \verb haero/processes/MAM4WaterUptakeProcess.hpp  for an
        example.
  \item Create a source file containing implementations for the constructor, the
        destructor, the \verb init  functon, and the \verb run  function for
        your subclass. This lives alongside the header file you just created.
        See \verb haero/processes/MAM4WaterUptakeProcess.cpp for an example.
        In particular, select the \verb ProcessType  value that reflects the
        proper stage of the aerosol lifecycle for your process.
  \item If your diagnostic process requires the presence of specific diagnostic
        variables, call the \verb set_diag_vars  function (with the appropriate
        variable names of each type) in the class's constructor.
  \item Add your source file to the set of source files in the
        \verb PROCESS_SOURCES  variable in \verb haero/processes/CMakeLists.txt .
  \item Write one or more tests for your new aerosol process.
        \refchapter{testing} provides extensive details about how to do this.
\end{enumerate}

\subsubsection{Implementing a diagnostic process in Fortran}
\labelsubsubsection{lib:diagnostic_f90}

A Fortran diagnostic process implementation consists of a C++ class derived
from the \verb FDiagnosticProcess  base class. As in the case of prognostic
processes, your C++ subclass is a thin wrapper around three Fortran subroutines
that live in their own module. This is illustrated in the
\verb MAM4WaterUptakeFProcess  defined in the following files:

\begin{itemize}
  \item \verb haero/processes/MAM4WaterUptakeFProcess.hpp : the C++ wrapper class
        declaration
  \item \verb haero/processes/MAM4WaterUptakeFProcess.cpp : the C++ wrapper class
        implementation, which calls the subroutines in the associated
        Fortran module. This source file must declare the names of the Fortran
        subroutines in an {\verb extern "C"} block in order for them to be
        visible to the C++ compiler.
  \item \verb haero/processes/mam4_water_uptake.F90 : the Fortran submodule, which
        defines the three subroutines called by the C++ wrapper class. These
        subroutines must be declared with the {\verb bind(c) } attribute, and
        must have the same name as those declared in the {\verb extern "C"}
        block in the C++ wrapper class implementation.
\end{itemize}

Again, the \verb FDiagnosticProcess  C++ class takes care of most of the work
needed for the C++/Fortran bridge. You simply supply the Fortran subroutines in
a module, and declare these subroutines in your class implementation.

So, to create a Fortran implementation for a diagnostic process:

\begin{enumerate}
  \item Create a header file that declares your subclass of
        \verb FDiagnosticProcess . Once again, this subclass needs only a
        constructor function. This header file lives in the
        \verb haero/processes  subdirectory within the repository.
  \item Create a Fortran module in which you define three subroutines that
        implement the \verb init , \verb update , and \verb finalize  behaviors
        for your process. Make sure these subroutines are public, and declare
        them with the \verb bind(c)  attribute to make them accessible to C++.
        This module lives in \verb haero/processes  with your C++ header file.
  \item Create a source that contains an implementation for the constructor
        function you declared in the header file above. In this constructor,
        you must call the constructor for the \verb FDiagnosticProcess  class.
        The arguments to this constructor include the type and name of the
        process, and the three Fortran subroutines you defined in your module.
        behaviors. These subroutines must be declared in an {\verb extern "C"}
        block within this file. The source file lives alongside the header file
        and the Fortran module you created.
  \item Make sure you call \verb set_diag_vars  in your C++ class's constructor
        function to list the diagnostic variables needed by your process.
  \item Add your C++ source file and Fortran module to the set of source files
        in the \verb PROCESS_SOURCES  variable in
        \verb haero/processes/CMakeLists.txt .
  \item Write one or more tests for your new aerosol process.
\end{enumerate}

\subsubsection{Making your diagnostic process available to Haero}

To make Haero aware of your new diagnostic process, you follow similar steps
to those for prognostic processes:

\begin{enumerate}
  \item Edit the \verb SelectedProcesses  struct in
        \verb haero/selected_processes.hpp  , and add a field to the enumerated
        type that corresponds to the \verb ProcessType  value you selected in
        Step 2 of your implementation procedure above.
  \item Edit the \verb select_diagnostic_process  function in
        \verb haero/selected_processes.cpp  to create a new pointer to your
        process type.
  \item Update the driver YAML input parser to add an option for a user
        to select your new process.
  \item Update this document with a description of your process in the
        appropriate section of \refchapter{processes}.
\end{enumerate}

It's helpful to look at examples of existing prognostic and diagnostic
processes before you get started on your own. In addition, it often helps to
think about how you might test a process to clarify and test your assumptions.
In the next chapter, we discuss Haero's approach to testing aerosol processes.
